// Generated by dts-bundle v0.7.3

declare module oteljs {
    export * from 'oteljs/contracts/Contracts';
    export * from 'oteljs/Activity';
    export * from 'oteljs/Contract';
    export * from 'oteljs/DataClassification';
    export * from 'oteljs/DataField';
    export * from 'oteljs/DataFieldHelper';
    export * from 'oteljs/DataFieldType';
    export * from 'oteljs/EventFlagFiller';
    export * from 'oteljs/EventFlagsProperties';
    export * from 'oteljs/OptionalEventFlags';
    export * from 'oteljs/OTelNotifications';
    export * from 'oteljs/SimpleTelemetryLogger';
    export * from 'oteljs/TelemetryLogger';
    export * from 'oteljs/TelemetryEvent';
    export * from 'oteljs/TelemetryProperties';
    export * from 'oteljs/TelemetrySink';
}

declare module 'oteljs/contracts/Contracts' {
    import { Activity, Result, Funnel, Host, SDX, UserAction } from 'oteljs/contracts/officeeventschema.tml';
    import { Error } from 'oteljs/contracts/Office.System.Error';
    import _Activity = Activity;
    import _Result = Result;
    import _Error = Error;
    import _Funnel = Funnel;
    import _Host = Host;
    import _SDX = SDX;
    import _UserAction = UserAction;
    export namespace Contracts {
        namespace Office {
            namespace System {
                export import Activity = _Activity;
                export import Result = _Result;
                export import Error = _Error;
                export import Funnel = _Funnel;
                export import Host = _Host;
                export import SDX = _SDX;
                export import UserAction = _UserAction;
            }
        }
    }
}

declare module 'oteljs/Activity' {
    import { DataField } from 'oteljs/DataField';
    import { ITelemetryLogger } from 'oteljs/TelemetryLogger';
    import { OptionalEventFlags } from 'oteljs/OptionalEventFlags';
    export interface IActivityScope {
            /**
                * Sets optional event flags.
                * @param eventFlags - Event flags to set
                */
            setEventFlags(eventFlags: OptionalEventFlags): void;
            /**
                * Adds a data field to the activity
                * @param dataField - A data field to add
                */
            addDataField(dataField: DataField): void;
            /**
                * Adds data fields to the activity
                * @param dataFields - Data fields to add
                */
            addDataFields(dataFields: DataField[]): void;
            /**
                * Sets whether the activity succeeded
                * @param success - Whether the activity succeeded
                */
            setSuccess(success: boolean): void;
            /**
                * Sets the result of the activity
                * @param resultCode - The result code
                * @param resultType - Optional: The result type
                * @param resultTag - Optional: The result tag
                */
            setResult(resultCode: number, resultType?: string, resultTag?: number): void;
            /**
                * Ends the activity; sends a telemetry event.
                */
            endNow(): void;
            /**
                * Creates an activity parented to the current activity. Does not start the activity.
                * @param activityName - The name of the activity
                */
            createChildActivity(activityName: string): IActivityScope;
            /**
                * Starts an activity to execute asynchronously
                * @param activityBody - The body of the activity
                */
            executeAsync<T>(activityBody: (activity: IActivityScope) => Promise<T>): Promise<T>;
            /**
                * Starts an activity to execute synchronously
                * @param activityBody - The body of the activity
                */
            executeSync<T>(activityBody: (activity: IActivityScope) => T): T;
            /**
                * Starts an activity to execute asynchronously, parented to the current activity.
                * @param activityName - The name of the activity
                * @param activityBody - The body of the activity
                */
            executeChildActivityAsync<T>(activityName: string, activityBody: (activity: IActivityScope) => Promise<T>): Promise<T>;
            /**
                * Starts an activity to execute synchronously, parented to the current activity.
                * @param activityName - The name of the activity
                * @param activityBody - The body of the activity
                */
            executeChildActivitySync<T>(activityName: string, activityBody: (activity: IActivityScope) => T): T;
    }
    /**
        * An activity scope, which automatically records duration and correlation vectors.
        * Activity scopes must have their result set with setResult or setSuccess.
        * The can be auto-ending when created with executeSync/executeAsync,
        * or their scope can be manually managed with createNew and endNow.
        * Child activities can be created with corresponding functions.
        */
    export class ActivityScope implements IActivityScope {
            /**
                * Creates a new Activity Scope that will be managed by the caller
                * One of setSuccess or setResult must be called on the scope, followed by endNow.
                * @param telemetryLogger - The telemetry logger that the activity belongs to
                * @param activityName - The name of the activity
                */
            static createNew(telemetryLogger: ITelemetryLogger, activityName: string): ActivityScope;
            /**
                * Creates an activity parented to the current activity. Does not start the activity.
                * @param activityName - The name of the activity
                */
            createChildActivity(activityName: string): IActivityScope;
            /**
                * Sets optional event flags.
                * @param eventFlags - Event flags to set
                */
            setEventFlags(eventFlags: OptionalEventFlags): void;
            /**
                * Adds a data field to the activity
                * @param dataField - A data field to add
                */
            addDataField(dataField: DataField): void;
            /**
                * Adds data fields to the activity
                * @param dataFields - Data fields to add
                */
            addDataFields(dataFields: DataField[]): void;
            /**
                * Sets whether the activity succeeded
                * @param success - Whether the activity succeeded
                */
            setSuccess(success: boolean): void;
            /**
                * Sets the result of the activity
                * @param resultCode - The result code, e.g. 0 for success
                * @param resultType - Optional: The result type, e.g. "HRESULT"
                * @param resultTag - Optional: The result tag
                */
            setResult(code: number, type?: string, tag?: number): void;
            /**
                * Ends the activity; records the duration and sends a telemetry event.
                */
            endNow(): void;
            /**
                * Starts an activity to execute asynchronously
                * You must call setSuccess or setResult on the activity inside the activity body.
                * When the activity body resolves or rejects, the duration is recorded and the activity is sent.
                * The promise resolution is passed through to the caller.
                * @param activityBody - The body of the activity, which should return a promise.
                */
            executeAsync<T>(activityBody: (activity: IActivityScope) => Promise<T>): Promise<T>;
            /**
                * Starts an activity to execute synchronously
                * You must call setSuccess or setResult on the activity inside the activity body.
                * When the function returns, the duration is recorded and the activity is sent. The return value is passed through to the caller.
                * @param activityBody - The body of the activity, which should return a promise.
                */
            executeSync<T>(activityBody: (activity: IActivityScope) => T): T;
            /**
                * Starts an activity to execute asynchronously, parented to the current activity.
                * @param activityName - The name of the activity
                * @param activityBody - The body of the activity
                */
            executeChildActivityAsync<T>(activityName: string, activityBody: (activity: IActivityScope) => Promise<T>): Promise<T>;
            /**
                * Starts an activity to execute synchronously, parented to the current activity.
                * @param activityName - The name of the activity
                * @param activityBody - The body of the activity
                */
            executeChildActivitySync<T>(activityName: string, activityBody: (activity: IActivityScope) => T): T;
    }
}

declare module 'oteljs/Contract' {
    import { DataField } from 'oteljs/DataField';
    /**
        * Get fields for a 'custom' contract that doesn't ship with OTel.js
        * You pass in the parameters for a contract, and this function returns the data fields in TelemetryEvent.dataFields format.
        * @param instanceName - The instance of the contract. Usually the same as the contract name without its namespace,
        *                       but can be different, especially if you have more than one of the same contract type in a single event.
        * @param contractName - The name of the contract, for example Office.System.SDX
        * @param contractFields - The data fields in the contract.
        */
    export function getFieldsForContract(instanceName: string, contractName: string, contractFields: DataField[]): DataField[];
    /**
        * Add a metadata field to the list of data fields indicating that a specific contract has been used.
        * For example, we might add the data field zC.MySdx: Office.System.SDX, which indicates that
        * the fields under MySdx conform to the Office.System.SDX contract.
        * @param dataFields - The list of data fields, to which a contract field will be added
        * @param instanceName - The instance of the contract. Usually the same as the contract name without its namespace,
        *                       but can be different, especially if you have more than one of the same contract type in a single event.
        * @param contractName - The name of the contract, for example Office.System.SDX
        */
    export function addContractField(dataFields: DataField[], instanceName: string, contractName: string): void;
}

declare module 'oteljs/DataClassification' {
    export enum DataClassification {
        EssentialServiceMetadata = 1,
        AccountData = 2,
        SystemMetadata = 4,
        OrganizationIdentifiableInformation = 8,
        EndUserIdentifiableInformation = 16,
        CustomerContent = 32,
        AccessControl = 64
    }
}

declare module 'oteljs/DataField' {
    import { DataFieldType } from 'oteljs/DataFieldType';
    import { DataClassification } from 'oteljs/DataClassification';
    /**
        * A boolean data field. Can be created with makeBooleanDataField
        */
    export interface BooleanDataField {
            name: string;
            dataType: DataFieldType.Boolean;
            value: boolean;
            classification?: DataClassification;
    }
    /**
        * An integer data field. Can be created with makeInt64DataField
        * Note that JavaScript doesn't actually support Int64 precision on large numbers.
        */
    export interface Int64DataField {
            name: string;
            dataType: DataFieldType.Int64;
            value: number;
            classification?: DataClassification;
    }
    /**
        * A double data field. Can be created with makeDoubleDataField
        */
    export interface DoubleDataField {
            name: string;
            dataType: DataFieldType.Double;
            value: number;
            classification?: DataClassification;
    }
    /**
        * A string data field. Can be created with makeStringDataField
        */
    export interface StringDataField {
            name: string;
            dataType: DataFieldType.String;
            value: string;
            classification?: DataClassification;
    }
    export type DataField = BooleanDataField | Int64DataField | DoubleDataField | StringDataField;
}

declare module 'oteljs/DataFieldHelper' {
    import { DataField } from 'oteljs/DataField';
    /**
        * Make a boolean data field.
        * @param name - The name of the data field
        * @param value - The value of the data field
        */
    export function makeBooleanDataField(name: string, value: boolean): DataField;
    /**
        * Make a data field corresponding to the Aria Int64 data type. Note that
        * JavaScript doesn't actually support Int64 precision on large numbers.
        * @param name - The name of the data field
        * @param value - The value of the data field
        */
    export function makeInt64DataField(name: string, value: number): DataField;
    /**
        * Make a double data field
        * @param name - The name of the data field
        * @param value - The value of the data field
        */
    export function makeDoubleDataField(name: string, value: number): DataField;
    /**
        * Make a string data field
        * @param name - The name of the data field
        * @param value - The value of the data field
        */
    export function makeStringDataField(name: string, value: string): DataField;
}

declare module 'oteljs/DataFieldType' {
    export enum DataFieldType {
        String = 0,
        Boolean = 1,
        Int64 = 2,
        Double = 3
    }
}

declare module 'oteljs/EventFlagFiller' {
    import { EventFlags } from 'oteljs/EventFlags';
    import { TelemetryEvent } from 'oteljs/TelemetryEvent';
    /**
      * Gets EventFlags from a STE.TelemetryEvent, filling them with default values if they don't exist
      * Note that the passed telemetry event is not changed
      * @param telemetryEvent - The telemetry event
      */
    export function getEffectiveEventFlags(telemetryEvent: TelemetryEvent): EventFlags;
}

declare module 'oteljs/EventFlagsProperties' {
    export enum SamplingPolicy {
            NotSet = 0,
            Measure = 1,
            Diagnostics = 2,
            CriticalBusinessImpact = 191,
            CriticalCensus = 192,
            CriticalExperimentation = 193,
            CriticalUsage = 194
    }
    export enum PersistencePriority {
            NotSet = 0,
            Normal = 1,
            High = 2
    }
    export enum CostPriority {
            NotSet = 0,
            Normal = 1,
            High = 2
    }
    /**
        * DataCategories
        * These can be combined with | as appropriate
        */
    export enum DataCategories {
            NotSet = 0,
            SoftwareSetup = 1,
            ProductServiceUsage = 2,
            ProductServicePerformance = 4,
            DeviceConfiguration = 8,
            InkingTypingSpeech = 16
    }
    /**
        * The diagnostic level of the event
        * For generic events, a user can be set to send no events, only basic events, or all (full and basic) events.
        * Services can also send events that are necessary for them to function; these are not affected by the above setting.
        * Instead, if the service is turned off, then it will stop functioning and no NecessaryServiceDataEvents will be sent.
        * AlwaysOnNecessaryServiceDataEvents are always on.
        */
    export enum DiagnosticLevel {
            ReservedDoNotUse = 0,
            BasicEvent = 10,
            FullEvent = 100,
            NecessaryServiceDataEvent = 110,
            AlwaysOnNecessaryServiceDataEvent = 120
    }
}

declare module 'oteljs/OptionalEventFlags' {
    import { CostPriority, SamplingPolicy, PersistencePriority, DiagnosticLevel, DataCategories } from 'oteljs/EventFlagsProperties';
    export interface OptionalEventFlags {
        costPriority?: CostPriority;
        samplingPolicy?: SamplingPolicy;
        persistencePriority?: PersistencePriority;
        dataCategories?: DataCategories;
        diagnosticLevel?: DiagnosticLevel;
    }
}

declare module 'oteljs/OTelNotifications' {
    import { IEventListeners } from 'oteljs/Event';
    export enum LogLevel {
            Error = 0,
            Warning = 1,
            Info = 2,
            Verbose = 3
    }
    export enum Category {
            Core = 0,
            Sink = 1,
            Transport = 2
    }
    export interface INotification {
            level: LogLevel;
            category: Category;
            message: () => string;
    }
    /**
        * Returns a list of notification event listeners. You can add an event listener:
        *    onNotification().addListener(event =\> \{
        *      console.log(event!.message + ' ' + event!.level); \});
        *
        * DO NOT trigger telemetry events on these notifications, as doing so may
        * create an infinite loop of telemetry events.
        */
    export function onNotification(): IEventListeners<INotification>;
    /**
        * Internal function: log a notification
        * @param level - The level of notification to log
        * @param category - The category of the notification
        * @param message - A function that returns a message to log
        */
    export function logNotification(level: LogLevel, category: Category, message: () => string): void;
}

declare module 'oteljs/SimpleTelemetryLogger' {
    import { TelemetryEvent } from 'oteljs/TelemetryEvent';
    import { DataField } from 'oteljs/DataField';
    import { Event } from 'oteljs/Event';
    import { TelemetrySink } from 'oteljs/TelemetrySink';
    export const SuppressNexus = -1;
    export interface ISimpleTelemetryLogger {
            /**
                * onSendEvent: Events that fire whenever sendTelemetryEvent processes an event
                */
            onSendEvent: Event<TelemetryEvent>;
            /**
                * persistentDataFields: Data fields that will automatically be sent with every event
                */
            persistentDataFields: DataField[];
            /**
                * Send a telemetry event
                * @param event - The event to send
                */
            sendTelemetryEvent(event: TelemetryEvent): void;
            /**
                * Add a sink for processing telemetry events
                * @param sink - A telemetry sink to which events will be passed when sendTelemetryEvent is called.
                */
            addSink(sink: TelemetrySink): void;
            /**
                * Set tokens to use for sending telemetry to Aria and/or Nexus
                * The tokens will be used for events which whose namespace exactly matches
                * @param namespace - The namespace for the tokens
                * @param ariaTenantToken - Optional: The Aria tenant token
                * @param nexusTenantToken - Optional: The Nexus tenant token
                */
            setTenantToken(namespace: string, ariaTenantToken?: string, nexusTenantToken?: number): void;
            /**
                * Set tokens to use for sending telemetry
                * The token tree is an object whose structure defines namespaces. At any level of the tree,
                * it can define values for 'ariaTenantToken' (string) and/or 'nexusTenantToken' (number).
                * These values are used as telemetry tokens for any events in that namespace or deeper.
                * @param tokenTree - An object containing tokens to use when sending telemetry
                */
            setTenantTokens(tokenTree: object): void;
    }
    /**
        * SimpleTelemetryLogger is the base implementation of a telemetry logger.
        * It exposes sendTelemetryEvent, which is used to log a telemetry event.
        */
    export class SimpleTelemetryLogger implements ISimpleTelemetryLogger {
            /**
                * A list of sinks that telemetry events will be forwarded to
                */
            onSendEvent: Event<TelemetryEvent>;
            /**
                * @internal Internal variable; do not use publicly.
                */
            telemetryEnabled: boolean;
            /**
                * @internal Internal variable; do not use publicly.
                */
            queriedForTelemetryEnabled: boolean;
            /**
                * @internal Internal variable; do not use publicly.
                */
            persistentDataFields: DataField[];
            /**
                * Creates a telemetry logger
                * @param parent - A parent telemetry logger that this telemetry logger should inherit from
                *                 This telemetry logger will send telemetry to the same sinks
                *                 and will send the same persistent data fields as the parent logger
                * @param persistentDataFields - Data fields to send with every event
                */
            constructor(parent?: ISimpleTelemetryLogger, persistentDataFields?: DataField[]);
            /**
                * SendTelemetryEvent is the basic way to send a telemetry event.
                * This should be used for sending telemetry about discrete events that happened
                * For telemetry that includes duration and/or success/failure, the Activity API may be more appropriate.
                * @param event - The telemetry event to send
                */
            sendTelemetryEvent(event: TelemetryEvent): void;
            /**
                * Processes a telemetry event, but does not send it
                *   Determines the tenant tokens
                *   Adds persistent data fields
                *   Validates the event
                * Throws if the event is invalid
                * @param event - The telemetry even to process
                */
            processTelemetryEvent(event: TelemetryEvent): void;
            /**
                * Adds a telemetry sink, to which events will be sent
                * @param sink - The telemetry sink to add
                */
            addSink(sink: TelemetrySink): void;
            /**
                * Sets a tenant token for a single namespace. Events within the namespace will be sent to the corresponding tenant.
                * @param namespace - The namespace to which the tokens apply, such as Office.System.
                * @param ariaTenantToken - The Aria tenant token
                * @param nexusTenantToken - The Nexus tenant token
                */
            setTenantToken(namespace: string, ariaTenantToken?: string, nexusTenantToken?: number): void;
            /**
                * Sets tenant tokens for multiple namespaces.
                * @param tokenTree - An that represents namespaces and which tenants to send corresponding tokens to
                *   For example, the following tree identifies where to send events under the Office.System and Office.Word namespaces.
                *                \{ Office: \{
                *                    System: \{
                *                      ariaTenantToken: 'foo',
                *                      nexusTenantToken: 100
                *                    \},
                *                    Word: \{
                *                      ariaTenantToken: 'bar',
                *                      nexusTenantToken: 200
                *                    \}
                *                \}\}
                */
            setTenantTokens(tokenTree: object): void;
            /**
                * FOR TEST ONLY. DO NOT USE.
                * Overrides environment variables that determine whether telemetry should be enabled.
                * @param enabled - Whether telemetry should be enabled
                */
            setIsTelemetryEnabled_TestOnly(enabled: boolean): void;
            /**
                * Clone a telemetry event; generally so we don't modify the input telemetry event
                * Also sets dataFields to [] if it isn't already set
                * @param event - The event to clone
                */
            cloneEvent(event: TelemetryEvent): TelemetryEvent;
    }
}

declare module 'oteljs/TelemetryLogger' {
    import { SimpleTelemetryLogger, ISimpleTelemetryLogger } from 'oteljs/SimpleTelemetryLogger';
    import { IActivityScope } from 'oteljs/Activity';
    import { DataField } from 'oteljs/DataField';
    import { OptionalEventFlags } from 'oteljs/OptionalEventFlags';
    import { Error } from 'oteljs/contracts/Office.System.Error';
    import { Contracts } from 'oteljs/contracts/Contracts';
    export interface ErrorEvent {
            eventName: string;
            error: Error.Contract;
            eventFlags?: OptionalEventFlags;
            dataFields?: DataField[];
    }
    export interface ITelemetryLogger extends ISimpleTelemetryLogger {
            /**
                * Starts an unparented activity to execute asynchronously
                * The caller must call setResult or setSuccess
                * Returns the result of the activityBody
                * @param activityName - The name of the activity
                * @param activityBody - The body of the activity
                */
            executeActivityAsync<T>(activityName: string, activityBody: (activity: IActivityScope) => Promise<T>): Promise<T>;
            /**
                * Starts an unparented activity to execute synchronously
                * The caller must call setResult or setSuccess
                * Returns the result of the activityBody
                * @param activityName - The name of the activity
                * @param activityBody - The body of the activity
                */
            executeActivitySync<T>(activityName: string, activityBody: (activity: IActivityScope) => T): T;
            /**
                * Creates a new activity. The caller is reponsible for setting the result and calling endNow.
                * @param activityName - The name of the activity
                */
            createNewActivity(activityName: string, parent?: IActivityScope): IActivityScope;
            /**
                * Advanced usage: Sends an activity. The caller is reponsible for setting all of the activity parameters.
                * @param activityName - The name of the activity
                * @param activity - The activity contract
                * @param dataFields - Optional additional data fields
                * @param optionalEventFlags - Optional event flags
                */
            sendActivity(activityName: string, activity: Contracts.Office.System.Activity.Contract, dataFields?: DataField[], optionalEventFlags?: OptionalEventFlags): void;
            /**
                * Sends an event with the Error data contract. A convenience wrapper around sendTelemetryEvent, with
                * an Error as a data field.
                * @param eventName - The name of the event
                * @param errorGroup - The group of the error
                * @param tag - The error tag
                * @param code - The error code
                * @param id - The error id
                * @param count - The count of the error
                * @param dataFields - Data fields to send with the event
                * @param eventFlags - Optional event flags to use for the error
                */
            sendError(event: ErrorEvent): void;
    }
    /**
        * A TelemetryLogger that includes more advanced functions than the SimpleTelemetryLogger,
        * specifically activities and errors.
        */
    export class TelemetryLogger extends SimpleTelemetryLogger implements ITelemetryLogger {
            /**
                * Starts an unparented activity to execute asynchronously
                * The caller must call setResult or setSuccess
                * Returns the result of the activityBody
                * @param activityName - The name of the activity
                * @param activityBody - The body of the activity
                */
            executeActivityAsync<T>(activityName: string, activityBody: (activity: IActivityScope) => Promise<T>): Promise<T>;
            /**
                * Starts an unparented activity to execute synchronously
                * The caller must call setResult or setSuccess
                * Returns the result of the activityBody
                * @param activityName - The name of the activity
                * @param activityBody - The body of the activity
                */
            executeActivitySync<T>(activityName: string, activityBody: (activity: IActivityScope) => T): T;
            /**
                * Creates a new activity. The caller is reponsible for setting the result and calling endNow.
                * @param activityName - The name of the activity
                */
            createNewActivity(activityName: string): IActivityScope;
            /**
                * Advanced usage: Sends an activity. The caller is reponsible for setting all of the activity parameters.
                * @param activityName - The name of the activity
                * @param activity - The activity contract
                * @param dataFields - Optional additional data fields
                * @param optionalEventFlags - Optional event flags
                */
            sendActivity(activityName: string, activity: Contracts.Office.System.Activity.Contract, dataFields?: DataField[], optionalEventFlags?: OptionalEventFlags): void;
            /**
                * Sends an event with the Error data contract. A convenience wrapper around sendTelemetryEvent, with
                * an Error as a data field.
                * @param eventName - The name of the event
                * @param errorGroup - The group of the error
                * @param tag - The error tag
                * @param code - The error code
                * @param id - The error id
                * @param count - The count of the error
                * @param dataFields - Data fields to send with the event
                * @param eventFlags - Optional event flags to use for the error
                */
            sendError(error: ErrorEvent): void;
    }
}

declare module 'oteljs/TelemetryEvent' {
    import { DataField } from 'oteljs/DataField';
    import { OptionalEventFlags } from 'oteljs/OptionalEventFlags';
    import { TelemetryProperties } from 'oteljs/TelemetryProperties';
    export interface TelemetryEvent {
        telemetryProperties?: TelemetryProperties;
        eventName: string;
        eventContract?: {
            name: string;
            dataFields: DataField[];
        };
        eventFlags?: OptionalEventFlags;
        dataFields?: DataField[];
    }
}

declare module 'oteljs/TelemetryProperties' {
    /**
        * Properties of the telemetry event
        */
    export interface TelemetryProperties {
            /**
                * The Nexus tenant token
                */
            nexusTenantToken: number;
            /**
                * The Aria tenant token
                */
            ariaTenantToken: string;
    }
}

declare module 'oteljs/TelemetrySink' {
    import { TelemetryEvent } from 'oteljs/TelemetryEvent';
    /**
        * Parent class Telemetry Sink. All Telemetry Sinks must have a sendTelemetryEvent function.
        */
    export interface TelemetrySink {
            /**
                * Send a telemetry event
                * @param event - The event to send
                * @param timestamp - Optional: Timestamp of when the event is created
                * in Unix Epoch time (integer value representing the number of milliseconds since 1 January 1970 00:00:00 UTC)
                */
            sendTelemetryEvent(event: TelemetryEvent, timestamp?: number): void;
    }
}

declare module 'oteljs/contracts/officeeventschema.tml' {
    import { DataField } from 'oteljs/DataField';
    export namespace Result {
        interface Contract {
            code: number;
            type?: string;
            tag?: number;
        }
        function getFields(instanceName: string, contract: Contract): DataField[];
    }
    export namespace Activity {
        const contractName = "Office.System.Activity";
        interface Contract {
            cV?: string;
            duration: number;
            count: number;
            aggMode: number;
            success?: boolean;
            result?: Result.Contract;
        }
        function getFields(contract: Contract): DataField[];
    }
    export namespace Host {
        interface Contract {
            id?: string;
            version?: string;
            sessionId?: string;
        }
        function getFields(instanceName: string, contract: Contract): DataField[];
    }
    export namespace SDX {
        interface Contract {
            id?: string;
            version?: string;
            instanceId?: string;
            name?: string;
            marketplaceType?: string;
            sessionId?: string;
            browserToken?: string;
            osfRuntimeVersion?: string;
            officeJsVersion?: string;
            hostJsVersion?: string;
            assetId?: string;
            providerName?: string;
            type?: string;
            url?: string;
        }
        function getFields(instanceName: string, contract: Contract): DataField[];
    }
    export namespace Funnel {
        interface Contract {
            name?: string;
            state?: string;
        }
        function getFields(instanceName: string, contract: Contract): DataField[];
    }
    export namespace UserAction {
        interface Contract {
            id?: number;
            name?: string;
            commandSurface?: string;
            parentName?: string;
            triggerMethod?: string;
            timeOffsetMs?: number;
        }
        function getFields(instanceName: string, contract: Contract): DataField[];
    }
}

declare module 'oteljs/contracts/Office.System.Error' {
    import { DataField } from 'oteljs/DataField';
    export namespace Error {
        interface Contract {
            errorGroup: string;
            tag: number;
            code?: number;
            id?: number;
            count?: number;
        }
        /**
          * Gets data fields for the Error Contract
          * @param instanceName - The instance name of this Error Contract
          * @param contract - The object containing data fields pertaining to the Error Contract
          */
        function getFields(instanceName: string, contract: Contract): DataField[];
    }
}

declare module 'oteljs/EventFlags' {
    import { CostPriority, SamplingPolicy, PersistencePriority, DataCategories, DiagnosticLevel } from 'oteljs/EventFlagsProperties';
    export interface EventFlags {
        costPriority: CostPriority;
        samplingPolicy: SamplingPolicy;
        persistencePriority: PersistencePriority;
        dataCategories: DataCategories;
        diagnosticLevel: DiagnosticLevel;
    }
}

declare module 'oteljs/Event' {
    export interface IEventListeners<TArgs> {
            addListener: (listener: (args: TArgs) => void) => void;
            removeListener: (listener: ((args: TArgs) => void)) => void;
            getListenerCount(): number;
    }
    export class Event<T> implements IEventListeners<T> {
            /**
                * Fires an event to its listeners
                * @param args - The parameters of the event
                */
            fireEvent(args: T): void;
            /**
                * Add an event listener
                * @param listener - The listener that can process events
                */
            addListener(listener: (args: T) => void): void;
            /**
                * Remove an event listener
                * @param listener - The listener to remove
                */
            removeListener(listener: ((args: T) => void)): void;
            /**
                * Get the count of event listeners
                */
            getListenerCount(): number;
    }
}

